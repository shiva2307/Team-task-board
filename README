# Team Task Board

Collaborative Kanban platform for cross-functional teams. Create projects, assign teammates, shuffle work between Todo / In Progress / Done, chat in the task, and track deadlines with realtime feedback across web and API layers.

---

## Table of Contents
- [Features](#features)
- [Tech Stack](#tech-stack)
- [System Architecture](#system-architecture)
- [Domain Model](#domain-model)
- [GraphQL Surface](#graphql-surface)
- [Frontend Experience](#frontend-experience)
- [Authentication & Security](#authentication--security)
- [Realtime Collaboration](#realtime-collaboration)
- [Local Development](#local-development)
- [Testing Strategy](#testing-strategy)
- [Deployment](#deployment)
- [Environment Variables](#environment-variables)
- [Roadmap](#roadmap)

---

## Features
- **Project Spaces**: Create projects with unique keys, role-based membership (Owner/Admin/Member), and shared labels.
- **Task Management**: Title, description, priority, due date, assignee, labels, threaded comments, attachments (future).
- **Board Ops**: Drag-and-drop across Todo / In Progress / Done, inline edit, keyboard shortcuts, column filtering, bulk operations (future).
- **Team Insights**: Activity feed, overdue indicators, priority badges, avatar stacks for ownership.
- **Optimistic UX**: React Query cache updates instantly while GraphQL mutations sync state.
- **Realtime Sync**: Subscriptions broadcast task moves, creations, and new comments to all connected clients.

## Tech Stack
- **Client**: Next.js 14 (App Router), TypeScript, React Query, Zustand, Tailwind CSS, Headless UI, `@dnd-kit/core`.
- **API**: Node.js 20, Apollo Server 4, GraphQL Yoga (subscriptions), Prisma ORM.
- **Auth**: NextAuth.js with credential + Google providers, stateless JWT sessions, bcrypt password hashing.
- **Storage**: MySQL 8 (AWS RDS in production), Redis Pub/Sub (Upstash) for subscription fan-out.
- **Tooling**: pnpm workspace, ESLint, Prettier, Vitest, Jest, Playwright, GitHub Actions, Docker Compose.

## System Architecture
```
┌────────────────┐      HTTP(S)/WS      ┌────────────────┐      SQL      ┌─────────────┐
│  Next.js Web   │◀────────────────────▶│  Apollo API    │◀─────────────▶│  MySQL 8    │
│ React + SSR/ISR│                     │  GraphQL Layer │             │  (Prisma)   │
│ React Query    │    Subscription Bus │                │   Pub/Sub   │             │
└────────────────┘◀────────────────────▶│ Redis Channels │◀────────────▶│ Redis (WS) │
```
- Next.js renders authenticated pages server-side, hydrates React Query caches, and issues GraphQL operations.
- Apollo Server exposes a single schema. Resolvers use Prisma for persistence and DataLoader for batching.
- GraphQL subscriptions ride over WebSocket (`graphql-ws`) with Redis bridging cluster nodes.
- NextAuth JWTs travel via HTTP-only cookies and feed user context to both web and API layers.

## Domain Model
Prisma schema highlights the collaborative data shape:
```prisma
model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  passwordHash  String?
  avatarUrl     String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  accounts      Account[]
  sessions      Session[]
  memberships   ProjectMember[]
  assignedTasks Task[]    @relation("TaskAssignee")
  comments      Comment[]
}

model Project {
  id          String   @id @default(cuid())
  name        String
  key         String   @unique
  description String?
  createdBy   String
  createdAt   DateTime @default(now())
  members     ProjectMember[]
  tasks       Task[]
  labels      Label[]
}

model ProjectMember {
  project   Project @relation(fields: [projectId], references: [id])
  projectId String
  user      User    @relation(fields: [userId], references: [id])
  userId    String
  role      Role
  joinedAt  DateTime @default(now())

  @@id([projectId, userId])
}

model Task {
  id          String        @id @default(cuid())
  project     Project       @relation(fields: [projectId], references: [id])
  projectId   String
  title       String
  description String?
  status      TaskStatus    @default(TODO)
  assignee    User?         @relation("TaskAssignee", fields: [assigneeId], references: [id])
  assigneeId  String?
  priority    TaskPriority  @default(MEDIUM)
  dueDate     DateTime?
  orderIndex  Float
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  comments    Comment[]
  labels      TaskLabel[]
}

model Comment {
  id        String   @id @default(cuid())
  task      Task     @relation(fields: [taskId], references: [id])
  taskId    String
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
  body      String
  createdAt DateTime @default(now())
}

model Label {
  id        String  @id @default(cuid())
  project   Project @relation(fields: [projectId], references: [id])
  projectId String
  name      String
  color     String
  tasks     TaskLabel[]

  @@unique([projectId, name])
}

model TaskLabel {
  task    Task  @relation(fields: [taskId], references: [id])
  taskId  String
  label   Label @relation(fields: [labelId], references: [id])
  labelId String

  @@id([taskId, labelId])
}

enum Role {
  OWNER
  ADMIN
  MEMBER
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
}
```
`orderIndex` is a float to permit O(1) inserts between neighbors during drag-and-drop without rewriting the full column.

## GraphQL Surface
```graphql
type Query {
  me: User
  projects(filter: ProjectFilter): [Project!]!
  project(id: ID!): Project
  task(id: ID!): Task
}

type Mutation {
  createProject(input: CreateProjectInput!): Project!
  inviteProjectMember(input: InviteMemberInput!): ProjectMember!
  createTask(input: CreateTaskInput!): Task!
  updateTask(input: UpdateTaskInput!): Task!
  moveTask(input: MoveTaskInput!): Task!
  addComment(input: AddCommentInput!): Comment!
  login(email: String!, password: String!): AuthPayload!
}

type Subscription {
  taskMoved(projectId: ID!): TaskMoveEvent!
  taskCreated(projectId: ID!): Task!
  commentAdded(taskId: ID!): Comment!
}

input MoveTaskInput {
  taskId: ID!
  status: TaskStatus!
  orderIndex: Float!
}

interface Node { id: ID! }
```
- RBAC gates each resolver using membership pulled from JWT context.
- Subscriptions publish via Redis channels keyed per project/task to support horizontal scaling.
- Optimistic updates reuse the same input payloads to patch React Query caches instantly.

## Frontend Experience
- **Routes**: `/login`, `/projects`, `/projects/[projectId]`, `/settings`.
- **State**: React Query for server state, Zustand for UI slices (modals, filters), Next.js server actions for mutations where appropriate.
- **Drag & Drop**: `@dnd-kit/core` sensors (pointer, touch, keyboard). Drop handler calculates new `orderIndex` (midpoint or +/- buffer) and triggers `moveTask` mutation.
- **UI**: Tailwind design tokens, Headless UI + Radix primitives, dark mode, accessible keyboard flows (`n` new task, `/` focus search, `?` shortcuts overlay).
- **Error Handling**: Mutation toasts via Radix Toast; fallback boundaries for page-level errors; skeleton loaders via Tailwind utilities.

## Authentication & Security
- NextAuth Credential provider validates via `login` mutation; Google OAuth uses NextAuth built-in provider.
- Stateless JWT stored in HTTP-only cookie; includes `userId`, `email`, `tokenVersion`.
- Project roles fetched lazily and cached in Redis for quick authorization decisions.
- Password reset flow issues signed token (JWT) and surfaces Next.js route for confirmation.
- Rate limiting (API gateway) and auditing (task/comment events stored in MySQL) planned for prod.

## Realtime Collaboration
- Apollo Server uses `graphql-ws` over WebSocket; HTTP fallback via SSE if needed.
- Redis Pub/Sub broadcasts task events; API nodes subscribe per project.
- Client hooks listen per project board, merging events back into React Query cache with id-based updates.
- Presence/typing indicators (future) powered by Redis streams or third-party (Ably/Pusher).

## Local Development
### Prerequisites
- Node.js 20+
- pnpm 8+
- Docker Desktop (for MySQL/Redis containers)
- Prisma CLI (`pnpm dlx prisma`)

### Setup
```bash
pnpm install
cp .env.example .env
pnpm prisma migrate dev
pnpm dev           # starts Next.js + Apollo (turborepo scripts)
```
- Next.js proxies `/api/graphql` to the standalone Apollo server running on `http://localhost:4000/graphql` during dev.
- `pnpm db:seed` populates sample users, projects, tasks for playground boards.

### Useful Scripts
- `pnpm lint`
- `pnpm typecheck`
- `pnpm test:unit`
- `pnpm test:integration`
- `pnpm test:e2e`
- `pnpm build`

## Testing Strategy
- **Unit**: Vitest for UI components; Jest for resolver/service logic with Prisma test harness.
- **Integration**: Playwright flows covering login, project creation, drag-and-drop, commenting.
- **Contract**: GraphQL operation snapshots using `graphql-request` and mocked Prisma.
- **End-to-End**: Playwright/Cypress hitting Docker-compose stack with seeded DB.
- **Static Analysis**: ESLint + TypeScript strict mode + Prisma format checks.

## Deployment
1. Build Docker images (`web`, `api`) via GitHub Actions.
2. Run smoke tests inside containers.
3. Push images to registry (GHCR or ECR).
4. Deploy to AWS ECS/Fargate or Kubernetes. Nginx/ALB routes `/` to Next.js, `/graphql` and `/subscriptions` to API service.
5. Migrate DB via Prisma migrate in release workflow.
6. Configure autoscaling policies on API/Web and enforce health checks.

Local Docker Compose layout:
```yaml
services:
  web:
    build: ./apps/web
    environment: [NEXTAUTH_URL, GRAPHQL_ENDPOINT]
  api:
    build: ./apps/api
    environment: [DATABASE_URL, REDIS_URL, JWT_SECRET]
  mysql:
    image: mysql:8
    environment: [MYSQL_ROOT_PASSWORD]
  redis:
    image: redis:7
```

## Environment Variables
- `DATABASE_URL=mysql://user:pass@host:3306/team_task_board`
- `NEXTAUTH_URL=http://localhost:3000`
- `NEXTAUTH_SECRET=...`
- `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`
- `JWT_SECRET=...`
- `REDIS_URL=redis://localhost:6379`
- `GRAPHQL_ENDPOINT=http://localhost:4000/graphql`
- `GRAPHQL_WS_ENDPOINT=ws://localhost:4000/subscriptions`

## Roadmap
- Calendar view aggregating due dates across projects.
- Slack/Teams webhooks and Jira import bridge.
- Advanced filters (label, assignee, due date range, text search).
- Task checklist items and file attachments.
- Presence indicators and typing notifications.
- Offline support with service worker caching and mutation queue.

---

This README describes the architecture and development plan for the Team Task Board. Use it as the blueprint to scaffold the codebase and infrastructure.
